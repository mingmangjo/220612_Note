2진수, 8진수, 16진수를 통해 하나의 수를 여러 방식으로 표현할 수 있다.

10진수를 n진수로 변환하는 방법은 n으로 나누고 나머지를 표기하고,
최종 몫이 n보다 작을 때까지 나눈 후 해당 몫부터 나머지를 역순으로 읽으면 된다.

n진수를 10진수로 변환하는 방법은 생략

실수의 n진법 표현은 정수의 n진법이 n^3,n^2,n^1...이라는 점과 같이
소수점 이하의 부분을 n^-1,n^-2...와 같이 표현하면 된다.
정수부와 소수부를 따로 계산하는 것이 편하다.

정수형 변수에서 음수를 표현할 때 저장공간의 가장 앞부분은 해당 값의 부호를 결정한다.
이때 0이면 양수, 1이면 음수인데, 음수를 표현하는 방식은 2의 보수법을 주로 사용한다.

a의 n의 보수 x는, a에 얼마의 값을 더했을 때 n이 되는 수(x)를 말한다.
즉 x=n-a

2진법으로 나타낸 두 수의 각 자릿값이 모두 2의 보수 관계일 때,
두 수를 더하면 0이 된다. 이에 착안해, 양수와 절댓값이 같은 음수를 2의 보수 관계에 해당하는 2진수로 배열한다.

2의 보수법으로 표현된 어떤 수의 절댓값을 알고 싶으면 해당 수의 1의 보수법에 해당하는 수에 1을 더하면 된다.

2의 보수 관계에 있는 두 수를 더할 경우 0이 되는데, 이는 해당 저장 공간이 모두 0이 되고 저장 공간의 바깥으로 자리올림이
발생해 이와 같은 현상이 가능한 것인데(overflow), 해당 값에서 다시 1를 빼면 저장공간이 모두 1로 가득 찬다는 점에서 착안된 것이다.
예를 들어 8bit를 저장공간으로 가지고 있는 어떤 두 수가 있다.
00101111=1+2+4+8+32=47, 이때 해당 수의 1의 보수는
11010000이고, 이 수에 1을 더한 11010001이 2의 보수이며, -47인 것이다.

변수 타입에 따라서 2의 보수법을 사용하는 경우가 있고, 0부터 양의 범위까지만 표현하는 타입이 있다.
char같은 경우 2byte 모두를 0부터 양의 범위까지 사용하기에 2의 보수법을 적용하지 않는다.

기본형은 총 8가지가 있다.
boolean, char, byte, short, int, long, float, double
각각 1,2,1,2,4,8,4,8byte를 저장 공간으로 차지한다.

boolean의 경우 값이 true, false 둘 중에 하나이기에 1bit 만으로도 충분하지만
java에서 처리하는 데이터의 최소 단위가 byte이기에 1byte의 크기를 차지한다.

char의 경우 문자형을 저장하지만 실제로 메모리 상에 저장되는 값은 수(문자의 유니코드)다.
해당 문자형이 어떤 유니코드로 저장되어 있는지 알고 싶다면 int casting을 통해 알아낼 수 있다.
ex) char a='A'; int code= (int)a;

short와 char 모두 2byte의 저장공간을 갖고, 정수형이 저장된다는 공통점이 있지만
변수타입의 선언에 의해 동일한 데이터가 어떻게 해석될지가 결정된다.
즉, 같은 크기의 변수 값이 메모리 상에 있다 하더라도, 해당 변수의 타입의 종류에 따라 해석의 방향이 달라지는 것이다.

문자를 코드로 변환하는 것을 encoding, 코드를 문자로 변환하는 것을 decoding이라고 한다.
유니코드 인코딩에는 UTF-8,UTF-16 등이 사용되는데 JAVA에서는 UTF-16이 사용된다.
UTF-16은 모든 문자형의 크기를 2byte로 고정하고, UTF-8은 1~4byte 가변 크기로 표현된다.
UTF-8은 다루기가 어렵지만 저장 크기가 작아 해당 인코딩으로 작성된 웹문서가 증가하고 있다.

정수형은 기본형이 int인데, byte나 short를 사용하더라도 JVM 피연산자 스택이 피연산자를 4byte 단위로
고정하기 때문에 처음부터 int를 사용하는 것이 효율적이다.
정수형을 사용할 때는 되도록 int형을 사용하고(저장공간의 효율성이 최우선이 아닌 경우), 표현하고자 하는 값이
20억 대를 넘을 경우 long을 사용하도록 한다.

해당 정수형이 표현할 수 있는 범위 밖의 값을 표현하고자 해 그 값이 제대로 표현되지 않는 현상을 overflow라 한다.

저장된 정수형 변수타입의 표현범위가 0이상일 경우 2의 보수법이 사용되지 않는데, 이 경우 0과 최댓값 부근에서 overflow가 발생한다.

저장된 정수형 변수타입이 음수를 표현하고, 해당 음수를 2의 보수법으로 표현할 경우 011111....에서 10000...으로 넘어 가는 부근에서
overflow가 발생한다. 저 두값 역시 각각 최댓값과 최솟값이다.

실수형의 경우 같은 크기의 저장공간을 지녔더라도 그 표현 방식의 차이에 의해 정수형보다 광범위한 표현을 할 수 있다.
float과 double 모두 음수,0,양수를 표현하며, 해당 표현법들은 2의 보수법을 사용하지는 않는다.
한편, 실수형은 overflow가 발생할 경우 무한대가 되고, 정수형과는 다르게 underflow가 발생한는데, 그 값은 0이 된다.

두 실수형 모두 저장공간이 S,E,M으로 구성되어 있는데
S: 부호
E: 지수
M: 가수
실수형은 +-M\*2^E로 표현된다.

이때 float은 E 부분에 8bit를 할당하고, M부분엔 23bit, S엔 1bit를 할당해 총 4byte를 차지한다.
한편 double은 E 부분에 11bit를 할당하고, M부분엔 52bit, S엔 1bit를 할당해 총 8byte를 차지한다.

어떤 실수를 저장할 때, 정규화가 이루어지는데,
M\*2^n으로 나타낸다. 이때, M은 1.xxxxxxx....xxx이며 소수점 아래 각각 float은 23자리, double은 52자리까지 저장 가능하다.
그 뒤의 수들은 모두 버림 처리 되어 각각의 실수형의 정밀도로 발현된다.

float의 지수부를 예를 들어 저장방식을 설명해보면,
float은 E에 8bit을 할당한다. 2^8은 256이고, -127~128까지 표현 가능하지만, 각 극단의 수는 무한대, NaN을 나타내기에
지수부의 최댓값은 127, 최솟값은 -126이다.
E에 해당하는 값은 기저법을 통해 메모리에 저장되는데, float의 기저(bias)는 127이다.
이를 통해 메모리에는 0~255까지 저장되지만 음수까지 표현이 가능하겠다.

double의 경우 float보다 3bit를 지수부 메모리에 더 할당해주는데, 2^11/2=1024이기에 double의 기저는 1023이 되겠다.

float의 정밀도가 7자리인 것은 가수부의 메모리가 23칸인 점 때문인데, 그 뒤의 값을 모두 버림으로써 얻을 수 있는
최대 오차값이 2^-23이 약 10^-7이기 때문이다.

형변환(casting)이란 두 변수 혹은 상수의 연산을 위해 하나의 타입으로 통일하는 것이다.
형변환을 통해서 원래 저장되어 있는 값에 영향은 끼치지 않는다.

primitive와 reference 타입은 서로 형변환이 불가능하다.
(기본형) (참조형)

기본형끼리는 대개 형변환이 가능한데, boolean을 제외한 7가지 종류의 타입끼리는 casting이 가능하다.

자세한 형변환 방식은 다음 정리 때 설명하겠다.
